#!/usr/bin/env bash
d_='# Meta Gear Manager

Manages package managers which work in user mode.


## Bootstrapping (Installing the GearManagers)

### As User

    ./gear bootstrap [-nb]

installs micromamba binenv asdf and optional (then requiring sudo at bootstrap time), nix and homebrew (-nb).

## Cloud Init (e.g. as root)

This

    #cloud-config

    runcmd:
    - wget "https://raw.githubusercontent.com/AXGKl/gear/master/gear"
    - chmod +x gear
    - ./gear -NB -u gk bootstrap

* creates a user gk (incl. authorized_keys of root) if not existing
* installs nix and linuxbrew (optional -NB) as root on the system
* chown of /home/linuxbrew/.linuxbrew for gk
* installs for user gk:
   - micromamba
   - binenv
   - asdf
* puts linuxbrew into the path



## Usage (Installing Gears)

### Spec

    gear sync|S [-f specfile] [-m match]

Specfile default: "./gears"


#### Spec Format

- <gearpackagename> [version] # optional comment (for matching)
- Line starting with $: Forces specific gearmanager until next $ line (default: auto, try all in order: binenv asdf nix micromamba brew)
- Shell syntax (# vim:ft=sh for syn hilite)
- Lines starting with # or empty : ignored


#### Example

    gdu 5.3.1
    neovim 0.9.1

    '\$'brew
    fzf

    '\$'nix
    firefox


# Nix

    nix repl --expr "import <nixpkgs>{}" -> type firef<TAB>
'

set -eu
unset IFS
export HOME="${HOME:-/root}"
export USER="${USER:-root}"
H="$HOME"
GEAR_DEBUG="${GEAR_DEBUG:-false}"
ALL_GEARMGRS="binenv asdf nix micromamba brew" # brew nix"
ALW_GEARMGRS="binenv micromamba asdf"          # in inst order. asdf req git and curl (from micromamba)
MM_D_BASE="$H/micromamba"
case "$(uname)" in Linux) OS=linux ;; Darwin) OS=darwin ;; *) OS= ;; esac
ARCH="amd64"
case "$(uname -m)" in arm | aarch64) ARCH='' ;; esac
BINENV_URL="https://github.com/devops-works/binenv/releases/download/v0.19.0/binenv_${OS:-}_$ARCH"
ASDF_REPO="https://github.com/asdf-vm/asdf.git"
BREW_URL="https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh"
BREW_DIR="/home/linuxbrew/.linuxbrew" # only here it's fast (bins work). this is not conda...
NIX_URL="https://nixos.org/nix/install"
NIX_URL_SELINUX="https://raw.githubusercontent.com/dnkmmr69420/nix-installer-scripts/main/installer-scripts/regular-nix-installer-selinux.sh"
FN_ACT_GEARS="$H/.activate_gears"
with_nix=false
with_brew=false
export NIXPKGS_ALLOW_UNFREE="${NIXPKGS_ALLOW_UNFREE:-1}"
FNLOG=
# ------------------------------------------------------------------------- UTILS
function now { date +%s%N | cut -b1-13; } # millis
function dt { local t0="${1:-$T0}" && echo -n $(($(now) - t0)); }
function out { printf "\x1b[2;36m%5s\x1b[0m %b\n" "$(dt)" "$*"; }
function title { out "\x1b[1;${2:-32}m$1\x1b[0m"; }
function nfo { out "(ℹ️) $*"; }
function good { out "🟩 $*"; }
function err { out "🟥 $*"; }
function die { set +x && err "$*" && exit 1; }
function shw { out "⚙️ $*" && "$@"; }
function shtit { title "$@" 33 && "$@"; }
function confirm {
    local conf && echo "$* [y/N]? " && read -r conf
    test "$conf" = "y" -o "$conf" = "y" && return 0 || die "Unconfirmed"
}
function silent { (set +x && echo -e "\n $(dt) cmd: $*" >>"$FNLOG" && "$@" 2>>"$FNLOG" 1>>"$FNLOG"); }
function try { silent "$@" || true; }
function have { silent type "$1"; }
function add_path { echo "$PATH" | grep -q "$1:" || export PATH="$1:$PATH"; }
function chmod_ { chmod +x "$1"; }
function tmpfn { local d="/tmp/$USER.gear" && mkdir -p "$d" && echo "$d/$1"; }
function waitfor { while true; do have "$1" && break || sleep 0.1; done; }
function download {
    silent wget -q "$1" -O "$2" || silent curl -L "$1" >"$2" || die "Download failed: $1 -> $2"
    test -z "${3:-}" && return 0
    "$3" "$2"
}

function inst_sys { # git wget or curl
    test "$(whoami)" = "root" || die "Require to be root for this. Sry..."
    local pkg="$1"
    test "$pkg" = "su" && pkg=util-linux
    test "$pkg" = "ps" && pkg=procps
    have apt && test "$pkg" = "xz" && pkg="xz-utils"
    nfo "Require cmd $1 -> installing package $pkg systemwide"
    have yum && silent yum install -qy "$pkg"
    have apt && { silent apt install -qy "$pkg" || silent apt -q update && silent apt install -qy "$pkg"; }
    have "$1" || die "could not install package for $1"
}
function source_shell_hooks { test -e "$FN_ACT_GEARS" && . "$FN_ACT_GEARS" || true; }
function set_sh_sep {
    local sep && sep="$1"
    SH_SEP1="# >>> $sep initialize >>>" # mamba style, only one which does it
    SH_SEP2="# <<< $sep initialize <<<"
}

function bootstrap_add_shell_hook {
    local fnt act name="$1" what="$2" fn="$FN_ACT_GEARS"
    touch "$fn"
    nfo "Modifying $fn for $name"
    set_sh_sep "$name"
    act="$SH_SEP1\n$what\n$SH_SEP2\n"

    grep -q "$SH_SEP1" <"$fn" || { echo -e "$act" >>"$fn" && return 0; } # had no hook yet
    fnt="$(tmpfn shhook)"
    grep -B 10000 "$SH_SEP1" <"$fn" | grep -v "$SH_SEP1" >"$fnt"
    echo -e "$act" >>"$fnt"
    grep -A 10000 "$SH_SEP2" <"$fn" | grep -v "$SH_SEP2" >>"$fnt"
    mv "$fnt" "$fn"
}

# ------------------------------------------------------------------------- CMDS

# -------------------------------------------------- Specific gears installation

_INST_GEARMGRS='' # all installed
_CUR_GEARMGR=''   # the one(s) to use (optionally set by install spec)

function set_installed_gearmgrs {
    local m a=''
    for m in $ALL_GEARMGRS; do
        silent "$m.bootstrapped" || continue
        a="$a $m"
    done
    _INST_GEARMGRS="$(echo "$a" | xargs)"
}

function single_gear_inst {
    # requires $_CUR_GEARMGR to be set (a list)!
    test -z "$_CUR_GEARMGR" && die "\$_CUR_GEARMGR not initialized"
    local v='' t='' gear="$1" ver="${2:-}"
    nfo "Gear: $gear. version: $ver. Trying $_CUR_GEARMGR"
    for t in $_CUR_GEARMGR; do
        v="$("$t.have" "$gear")"
        test -z "$v" || { echo "$v" | grep -q "$ver" && good "Already present: $gear $v [$t]" && return 0; }
        test -z "$v" || nfo "Wrong version: $t $gear $v"
        shw "$t.install" "$gear" "$ver" && return 0 || true
    done
    die "$gear: No installer found"
}
function binenv.have { binenv versions -f | grep "^$1" | cut -d = -f 2 | xargs; }
function asdf.have { asdf list "$1" | sed -e 's/*//g' | xargs; }
function micromamba.have { micromamba list -q --json "$1" | grep version | cut -d : -f 2 | xargs; }
function nix.have { nix-env --query | grep "^$1" | cut -d '-' -f 2 | xargs; }
function brew.have { brew list "$1" --versions | cut -d ' ' -f 2 | xargs; }

function binenv.install { binenv install "$1" "${2:-}"; }

function asdf.install {
    local ver="${2:-latest}"
    (shw asdf plugin add "$1") || return 1
    shw asdf install "$1" "$ver"
    shw asdf global "$1" "$ver" # writes to ~/.gear-versions
}
function micromamba.install {
    local t="$1" && test -z "${2:-}" || t="$t==$2"
    shw micromamba install -q -y "$t"
}
function nix.install {
    # nix-env -iA nixpkgs.python3Packages.zodb => installs lib
    # OR from https://lazamar.co.uk/nix-versions/?channel=nixos-unstable&package=nodejs:
    # nix-env -iA nodejs_20 -b -f https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz
    local is_tar=false ver="${2:-}"
    echo "$ver" | grep -q '.tar' && is_tar=true
    test -z "$ver" && {
        shw nix-env --prebuilt-only -iA "nixpkgs.$1"
        return $?
    }
    $is_tar && {
        shw nix-env --prebuilt-only -iA "$1" -f "https://github.com/NixOS/nixpkgs/archive/$2"
        return $?
    }
    return 1
}
function brew.install {
    local t="$1" && test -z "${2:-}" || t="$t@$2"
    brew install "$t"
}
function binenv.list { binenv versions -f; }
function asdf.list { asdf list; }
function micromamba.list { micromamba list; }
function nix.list { nix-env --query; }
function brew.list { brew list --versions; }

function binenv.query { binenv search "$1"; }
function asdf.query { ls "$HOME/.asdf/repository/plugins" | grep "${1:-}"; }
function micromamba.query { rg "$1" | grep name | cut -d : -f 3 | uniq; }
function nix.query { cd "/nix/var/nix/profiles/per-user/root/channels/nixpkgs/pkgs" && rg "$1"; }
function brew.query {
    cd /home/linuxbrew/.linuxbrew
    test -e "./homebrew-core" || git clone --depth=1 https://github.com/Homebrew/homebrew-core
    cd homebrew-core
    rg -A1 'desc ' | rg -A1 -i "$1"
}

function gear.query {
    local ti
    set_installed_gearmgrs
    have rg || silent binenv install rg
    for ti in $_INST_GEARMGRS; do title "Query $ti" && "$ti.query" "${1:-}" || true; done
}
function gear.list {
    local ti
    set_installed_gearmgrs
    for ti in $_INST_GEARMGRS; do title "Installed by: $ti" && "$ti.list" | grep "${1:-}" || true; done
}
function gear.install {
    # write a "spec" and sync it:
    local tmp_spec && tmp_spec="$(tmpfn pkgs)"
    rm -f "$tmp_spec"
    # allow gear i @nix nodejs AND gear i \$nix nodejs
    while [[ $# -gt 0 ]]; do echo "$1" | sed -e 's/^@/$/g' | xargs >>"$tmp_spec" && shift; done
    silent cat "$tmp_spec"
    gear.sync -f "$tmp_spec"
}

function gear.sync {
    local fn t ti gear='' spec="./gears" match=''
    set_installed_gearmgrs
    _CUR_GEARMGR="$_INST_GEARMGRS"

    while getopts f:m: opt; do
        case "$opt" in
            f) spec="$OPTARG" ;;
            m) match="$OPTARG" ;;
            ?) die "not supported: $opt" ;;
        esac
    done
    test -e "$spec" || die "Not found spec file $spec"
    # read the spec, line by line. lines starting with $ set the cur_gearmgr:
    while read -r p; do
        gear="$(echo "$p" | grep -v "^#" | xargs)"
        test -z "$gear" && continue
        t=false
        test "$gear" = "\$mm" && gear="\$micromamba"
        test "$gear" = "\$auto" && _CUR_GEARMGR="$_INST_GEARMGRS" && t=true
        for ti in $_INST_GEARMGRS; do
            test "$gear" = "\$${ti}" && {
                _CUR_GEARMGR="${gear#\$*}"
                t=true
                break
            }
        done
        $t && continue
        echo "$gear" | grep -q "$match" || { nfo "Skipping $gear" && continue; }
        gear="${gear%#*}" # cut off comments (which match)
        title "Try install $gear"
        eval 'single_gear_inst '$gear''
    done <"$spec"
}

# -------------------------------------------------- Gear Manager Operations
function activate_all { for k in $ALL_GEARMGRS; do try "${k}.activate"; done; }

function gear.status {
    for t in $ALL_GEARMGRS; do
        "$t.bootstrapped" && { good "$t" && "$t.status" || true; } || err "$t"
    done
}

function gear.bootstrap {
    local act mgrs="$ALW_GEARMGRS"
    while getopts onb opt; do
        case "$opt" in
            o) mgrs="" ;; # must be before n and b
            n) mgrs="$mgrs nix" ;;
            b) mgrs="$mgrs brew" ;;
            ?) die "not supported: $opt" ;;
        esac
    done

    true Boostrapping <<'    📓'
    We consider a gear manager "bootstrapped", when the shell hook was evaled.

    Eval does:

    - for binenv: path added
    - for asdf: asdf.sh sourced
    - for mm: micromamba avail as FUNCTION (not necessarily yet activated)

    I.e. the bootstrapping process does add the shell hook to `.<bash | zsh >rc`.
    User can change that and eval in other places but those should be evaled FROM shellrc as well.
    📓
    test -e "$HOME/.local/bin/gear" || { mkdir -p "$HOME/.local/bin" && cp "$0" "$HOME/.local/bin/gear"; }
    act="source $FN_ACT_GEARS"
    grep -q "^$act" <"$HOME/.bashrc" || {
        local fn && fn="$(tmpfn brc)" # maybe no sed
        echo -e "$act\n\n" >"$fn"
        cat "$H/.bashrc" >>"$fn"
        mv "$fn" "$H/.bashrc"
    }
    local inst=false
    for t in $mgrs; do
        "$t.bootstrapped" && nfo "Have $t" || { inst=true && shtit "$t.bootstrap"; }
    done
    $inst || { good "Already present: $mgrs" && return 0; }
    source_shell_hooks
    for t in $mgrs; do "$t.bootstrapped" || die "Could not bootstrap $t"; done
    gear.status || true
}
function gear.ensure_runnable {
    test -z "${OS:-}" && die "Only linux or osx. sorry..." || true
    have wget && return
    have curl && return
    inst_sys wget
}
function gear.help {
    echo -e "$d_"
    test "${1:-}" = false && return || exit 0
}
# ------------------------------------------------------------------------- GEARS
function binenv.bootstrapped { have binenv; } # -> PATH seems set.
function binenv.status { binenv versions -f; }
function binenv.bootstrap {
    local fn
    fn="$(tmpfn binenv)"
    shw download "$BINENV_URL" "$fn" chmod_
    shw "$fn" update && shw "$fn" install binenv
    bootstrap_add_shell_hook "binenv" 'echo "$PATH" | grep -q binenv || PATH="$HOME/.binenv:$PATH"'
}
function binenv.activate { add_path "$H/.binenv" && have binenv; }

function asdf.get_ { export ASDF_REPO && shw git clone "$ASDF_REPO" "$H/.asdf" --branch v0.12.0; }
function asdf.bootstrapped { have asdf; }
function asdf.status { asdf plugin list; }
function asdf.bootstrap {
    test -e "$H/.asdf" || with_git_curl asdf.get_
    bootstrap_add_shell_hook "asdf" 'source "$HOME/.asdf/asdf.sh"'
}
function with_git_curl {
    # $1 a function
    have git && have curl && {
        "$1" || die "could not run installer"
        return 0
    }
    nfo "installer requires git, curl -> installing via micromamba (up to 1 min...)"
    source_shell_hooks
    micromamba activate base
    shw silent micromamba install -y git curl 1>/dev/null
    "$1" || die "could not run installer"
    shw type git
}
function asdf.activate { silent . "$H/.asdf/asdf.sh"; }

function micromamba.bootstrapped {
    have micromamba && test -e "$MM_D_BASE" && type micromamba | grep -q install
}
function micromamba.status { micromamba info | grep 'base environment'; }
function set_condarc { grep -q "^$2:" <"$1" || echo -e "$3\n" >>"$1"; }
function micromamba.bootstrap {
    export CONDA_FORGE_YES=yes
    export INIT_YES=no
    local fn
    fn="$(tmpfn mamba_installer)"
    download "https://micro.mamba.pm/install.sh" "$fn"
    echo '' | "${SHELL}" <(cat "$fn") # install

    fn="$H/.condarc"
    set_condarc "$fn" "auto_activate_base" 'auto_activate_base: true'
    set_condarc "$fn" "auto_update_conda" 'auto_update_conda: false'
    set_condarc "$fn" 'pkgs_dirs' "pkgs_dirs:\n  - \${HOME}/micromamba/pkgs"

    local a="export MAMBA_EXE='$HOME/.local/bin/micromamba'"
    a="$a\nexport MAMBA_ROOT_PREFIX='$HOME/micromamba'"
    a=''$a'\neval "$($MAMBA_EXE shell hook -s bash -r $MAMBA_ROOT_PREFIX)"'
    mkdir -p "$H/micromamba"
    shw micromamba.build_cache
    bootstrap_add_shell_hook micromamba "$a"
}
function micromamba.build_cache { silent micromamba -p "$H/micromamba" install -qy xxx || true; }

function nix.bootstrapped {
    bash -ic 'nix --version'
}
function nix.bootstrap {
    nix.bootstrapped && return 0
    local url fn && url="$NIX_URL" && fn="$(tmpfn instnix)"
    test "$(getenforce 2>/dev/null)" = "Enforcing" && {
        hash semanage || die "Require semanage on an selinux system"
        url="$NIX_URL_SELINUX"
    }
    download "$url" "$fn" chmod_
    "$fn" --daemon --yes # asks for sudo if not root
}
function nix.status { nix doctor; }

function brew.bootstrapped { have brew; }
function brew.status { brew list; }
function brewinst { /bin/bash -c "$(curl -fsSL "$BREW_URL")" && shw brew.build_cache; }
function brew.bootstrap {
    local d="$BREW_DIR"
    silent touch "$d/geartest" || { # already owned?
        test -e "$d" && { have sudo && sudo chown -R "$(whoami)" "$d"; }
        test -e "$d" && { have sudo || chown -R "$(whoami)" "$d"; }
        test -e "$d" || with_git_curl brewinst
    }
    try rm -f "$d/geartest"
    bootstrap_add_shell_hook "brew" 'eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"'
}
function brew.build_cache { silent "$BREW_DIR/bin/brew" install hello; }

function gear_for_user_by_root {
    # root installs for a specific user - creating it:
    # Then we install already here nix and brew, so that sudo is not required later
    local nb='' hu='' user=$1 && shift
    test "$(whoami)" = "$user" && return 0
    test "$(whoami)" = "root" || die "Require root to run usermode for user $user"
    hu="/home/$user"
    have su || inst_sys su
    have ps || inst_sys ps # at least brew and conda

    su - "$user" -c 'echo ""' || {
        $INTERACTIVE && confirm "ok to create user $user"
        useradd -md "$hu" -s /bin/bash "$user" || echo "User exists already"
        mkdir -p "$hu/.ssh"
        test -e "$HOME/.ssh/authorized_keys" && {
            cp "$HOME/.ssh/authorized_keys" "$hu/.ssh/" # handy on server installs
            chown -R "$user:$user" "$hu/.ssh"
        }
        su - "$user" -c "mkdir -p $hu/.local/bin"
        chown -R "$user:$user" "$hu/.local"
    }

    test "$1" = bootstrap && {
        have wget || have curl || inst_sys wget
        $with_nix && {
            nb="-n $nb"
            have xz || inst_sys xz
            nix.bootstrap
        }
        $with_brew && {
            nb="-b $nb"
            test -e "/home/linuxbrew/.linuxbrew" || {
                touch /.dockerenv # then brew will not complain about root
                download "$BREW_URL" /tmp/bi chmod_
                have git || inst_sys git
                have curl || inst_sys curl
                NONINTERACTIVE=1 CI=1 /tmp/bi
            }
            chown -R "$user:$user" /home/linuxbrew/.linuxbrew
        }
    }
    hu="$hu/.local/bin/gear"
    cp "$0" "$hu"
    chown -R "$user:$user" "$hu"
    su - "$user" -c "export GEAR_DEBUG=$GEAR_DEBUG && eval $hu $* $nb"
    exit $?
}
# -------------------------------------------------- main
function main {
    T0=$(now) && export T0
    FNLOG="$(tmpfn gearlog)" && export FNLOG && echo '' >"$FNLOG"

    [ -t 0 ] && INTERACTIVE=true || INTERACTIVE=false
    silent ls /root/ && HAVE_ROOT=true || HAVE_ROOT=false
    title "$0 $*"
    local cmd user=''
    cmd="${1:-help}"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -NB) with_nix=true && with_brew=true ;;
            -N | --with-nix) with_nix=true ;;
            -B | --with-brew) with_brew=true ;;
            -u | --user) user="$2" && shift ;;
            -y | --yes) export INTERACTIVE=false ;;
            -x | --debug) set -xv && export GEAR_DEBUG=true ;;
            -h | --help) cmd=help && break ;;
            up | bootstrap) cmd=bootstrap && break ;;
            i | install) cmd=install && break ;;
            l | list) cmd=list && break ;;
            q | query) cmd=query && break ;;
            s | status) cmd=status && break ;;
            S | sync) cmd=sync && break ;;
            2readme) "$0" -h 2>/dev/null >README.md && exit ;;
            *) echo "$1 not supported" && exit 1 ;;
        esac
        shift
    done
    test "$cmd" = "help" && gear.help "$@" # exits
    shift
    test -z "$user" || gear_for_user_by_root "$user" "$cmd" "$@"
    gear.ensure_runnable && source_shell_hooks
    "gear.$cmd" "$@"
}

main "$@"
